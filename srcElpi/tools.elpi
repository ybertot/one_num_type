% sorting a list of integers removing duplicates
pred list_insert i:int, i:list int, o:list int.

list_insert I [] [I].

list_insert A [A | L] [A | L] :- !.

list_insert I [A | L] [I, A | L] :-
  I < A, !.

list_insert I [A | L] [A | L1] :-
  list_insert I L L1, !.
  
% sorting a list of integers: the main predicate

pred list_sort i:list int, o:list int.
list_sort [] [].

list_sort [A | L] L1 :-
  list_sort L L2, !,
  list_insert A L2 L1.

pred list_max i:list int o:int.
list_max [A] A.

list_max [A, B | L]  V:-
  A < B, !, list_max [B | L] V.

list_max [A, _B | L] V :-
  list_max [A | L] V.

% sorting an association list for values associated to integers

pred alist_insert i:pair int term, i:list (pair int term),
  o:list (pair int term).

alist_insert (pr I _) [pr I _ | _] _ :- !,
  coq.error "There are two declarations for the same integer"  I.

alist_insert (pr I V) [pr I2 V2 | L] [pr I V, pr I2 V2 | L] :-
  I < I2, !.

alist_insert (pr I V) [pr I2 V2 | L] [pr I2 V2 | L2] :-
  alist_insert (pr I V) L L2.

alist_insert (pr I V) [] [pr I V].

pred alist_sort i:list (pair int term), o:list (pair int term).

alist_sort [] [].

alist_sort [A | L] L2 :-
  alist_insert A L L2.

% converting a coq object of type positive to a builtin int
pred positive_to_int i:term, o:int.
% TODO regarder dans algebra tactics
positive_to_int {{xH}} 1 :- !.

positive_to_int {{:coq xI lp:X}} N1 :-
  positive_to_int X N,
  N1 is 2 * N + 1.

% TODO
positive_to_int {{xO lp:X}} N1 :-
  positive_to_int X N,
  N1 is 2 * N.

% converting a real number to an int
pred real_to_int i:term, o:int.

% actually, this works for any positive number encapsulated in two unary
% functions
real_to_int {{IZR (Z.pos lp:P)}} I :-
  positive_to_int P I.

real_to_int {{0}} 0.

% the inverse predicate, int_to_real, produces a real number that is
% the representation of the integer.

pred int_to_real i:int, o:term.

int_to_real I {{IZR lp:Iz}} :-
  int_to_Z I Iz.

pred int_to_Z i:int, o:term.
int_to_Z 0 {{Z0}} :- !.

int_to_Z I {{Z.pos lp:Ip}} :-
  int_to_positive I Ip.

pred int_to_positive i:int, o:term.
int_to_positive 1 {{xH}}:- !.

int_to_positive N (app[C, Td]) :-
  1 < N,
  Nd is N div 2,
  B is N mod 2,
  choose_pos_constructor.aux B C,
  int_to_positive Nd Td.

pred int_to_nat i:int, o:term.
int_to_nat 0 {{O}} :- !.

int_to_nat N {{S lp:N'}} :-
  std.do! [
    0 < N,
    N1 is N - 1,
    int_to_nat N1 N'
  ].
  
pred choose_pos_constructor.aux i:int, o:term.

choose_pos_constructor.aux 1 {{xI}} :- !.

choose_pos_constructor.aux 0 {{xO}} :- !.

choose_pos_constructor.aux _ _ :-
  coq.error "choose_pos_constructor.aux only accepts 0 or 1 as input".

pred make_one_spec i:term, i:term, o:pair int term.
make_one_spec V1 V2 (pr I1 V2) :-
  real_to_int V1 I1,!.

pred list_app i:list (pair int term), i:list (pair int term),
  o:list (pair int term).

list_app [] L2 L2.

list_app [A | L1] L2 [A | L3] :-
  list_app L1 L2 L3.